# **페이지네이션되는 게시판 만들기**  
# **프로젝트 구조 소개**  
프로젝트 구조는 N 계층 아키텍처를 따른다. MVC 패턴으로도 불리는 아주 유명하고 많이 쓰이는 구조다. 뷰는 유저가 보는 화면을 말한다. HTML 템플릿 엔진은 
핸들바(handlebars)로 작성한다. 컨트롤러는 따로 디렉터리를 구분하지는 않고 app.js안에 라우터 함수들로 분리한다. 서비스는 post-service.js 하나만 
만든다(원한다면 다양한 서비스를 만들 수 있다). 구조상으로는 모델에서 데이터베이스와 통신하게 되어 있지만 명시적으로 모델을 만들지는 않고 몽고디비 라이브러리의 
컬렉션 객체가 모델 역할을 한다.  
  
![img.png](image/img.png)  
  
# **게시판 프로젝트 셋업**  
프로젝트를 생성하고 익스프레스, 핸들바, 몽구스 패키지를 설치한다.  
  
# **Node.js 프로젝트 초기 설정**  
1. board 디렉터리를 만들고 npm init로 초기화한다.  
npm init -y  
  
# **익스프레스 설치 및 프로젝트 디렉터리 구조 잡기**  
1. 익스프레스 패키지를 설치한다.  
npm i express@4.17.3  
npm i mongodb@4.13.0  

2. 게시판 프로젝트의 디렉터리 구조를 잡는다.  
익스프레스는 마이크로 프레임워크다. 익스프레스 홈페이지에서는 미니멀리스트 웹 프레임워크로 소개한다. 표현은 다르지만 최소 기능을 가지면서 필요한 기능을 
플러그인으로 확장하는 프레임워크를 의미한다는 사실은 같다. 보통 모든 기능을 제공하는 풀스택 프레임워크들은 디렉터리 구조를 강제한다. 대표적으로 장고를 
들 수 있다. 반면 마이크로 프레임워크는 디렉터리 구조를 강제하지 않는다. 사용자에게 자유도를 주어 좋은 면도 있지만 좋은 디렉터리 구조를 사용자가 직접 
고민해야 한다.  
  
여기서는 서버 개발에서 가장 보편적으로 사용되는 3계층 구조(3 tier) 아키텍처를 적용한다. 3계층 구조는 웹 프레임워크에서 주로 사용하는 MVC 패턴을 
적용하기에도 좋다.  
  
3계층 구조는 다음과 같이 컨트롤러, 서비스, 데이터 액세스 계층을 갖는다. 컨트롤러 계층에서는 뷰에서 넘어온 요청을 받아서 권한 체크, 유효성 검증 등을 
한 후에 서비스 계층으로 넘긴다. 서비스 계층에서는 비즈니스 로직을 처리한다. 서비스로 비즈니스 로직을 분리하면 각각 다른 컨트롤러에서 같은 서비스를 
재사용할 수 있게 된다. 서비스에서 DB에 데이터를 저장할 때는 데이터 엑세스 계층과 데이터를 주고받는다. 이 경우 정의해둔 모델을 넘기는 것이 일반적이다.  
  
![img.png](image/img2.png)  
  
익스프레스에서 컨트롤러 역할은 라우터가 한다. 서비스 계층은 비즈니스 로직을 구현하는 부분이므로 각 프로젝트에서 해당 역할을 하는 클래스 또는 함수를 
작성해야 한다. 몽고디비 모듈이 데이터 액세스 계층 역할을 해주게 된다. 필요에 따라서 데이터 액세스 계층을 따로 작성하는 경우도 있다.  
  
3계층 아키텍처는 서버의 관점에서 데이터와 파일을 어떻게 관리할지 정리한 것이지만 게시판 프로젝트에서는 웹페이지도 있다.  
  
![img.png](image/img3.png)  
  
디렉터를 각 계층별로 만든다. 뷰 관련 파일은 views 디렉터리, 컨트롤러 관련 파일은 controllers 디렉터리, 서비스 관련 파일은 services 디렉터리를 
사용한다. 다만 이번 장에서 다루는 API들이 많지 않으므로 라우터와 컨트롤러 코드는 app.js에 모두 작성한다. 마지막으로 각 모듈에서 사용할 설정 파일이 
필요한 경우도 있다. 설정 파일을 모아놓을 configs 디렉터리도 생성한다.  
  
3. 프로젝트의 디렉터리 구조는 다음과 같다. 디렉터리와 파일을 생성한다.  
  
![img.png](image/img4.png)  
  
# **핸들바 템플릿 엔진 설치 및 설정하기**  
API만 만드는 것이라면 템플릿 엔진이 필요 없다. 뷰로 웹페이지를 보여주므로 템플릿 엔진을 설정해야 컨트롤러에서 넘기는 데이터를 웹페이지에 제대로 표현할 
수 있다.  
  
익스프레스에서 사용하는 템플릿 엔진으로는 퍼그(Pug), EJS, 머스태시(mustache)등이 있지만 퍼그는 HTML이 아닌 다른 포맷으로 웹페이지를 작성해야 하므로 
제외한다. EJS는 표션식이 좀 지저분하다. 머스태시는 다양한 언어에서 사용되는 템플릿 엔진과 유사하지만 핸들바에 비해 기능이 적다. 핸들바는 머스태시와 
호환되면서 추가 기능을 제공하므로 핸들바를 사용한다.  
  
1. 핸드바 express-handlebars를 설치한다. 익스프레스용 핸들바 패키지는 express-handlebars와 express-hbs 두 가지가 있다. express-hbs가 조금 
더 많은 기능을 제공하지만 2023년 시점으로 마지막 버전이 2년 전에 공개되었다. 이에 기능은 조금 더 적더라도 관리가 잘되고 있는 express-handlebars를 
사용한다. 많은 차이는 없으므로 둘 중 어느 것을 사용해도 크게 문제는 없다.  
  
npm i express-handlebars@6.0.3  
  
2. 설치가 잘되었으면 설정을 진행한다. app.js 파일을 생성하고 작성한다.  
board/app.js  
  
app.engine은 익스프레스에서 사용할 템플릿 엔진을 등록하는 코드다. handlebars는 파일의 확장자로 사용할 이름이다. hbs 등의 다른 이름으로 변경할 수 있지만 
핸들바 엔진 내부에서 handlebars로 사용하고 있으므로 변경하지 않는다. 파일이 많아지면 변경하는 것도 좋다.  
  
엔진을 설정했지만 웹페이지에서 사용할 템플릿 엔진도 설정해야 한다. 설정 시에는 엔진 설정 시의 이름 "handlebars"로 설정해 준다. 이름을 hbs로 했다면 여기서
도 hbs로 해야한다.  
  
views는 뷰로 사용할 파일들의 디렉터리를 설정하는 코드다. 기본적으로 views로 되어 있지만 node를 실행하는 디렉터리의 상대 경로로 지정된다. 상대 경로로 
되어 있을 때 다른 디렉터리에서 node를 실행하면 문제가 생길 수 있으므로 __dirname을 사용해 절대 경로로 지정한다. __dirname은 node를 실행하는 
디렉터리 경로다.  
  
라우팅 코드의 home은 템플릿 파일의 이름이다. views가 기본 경로이고 handlebars가 확장자이므로 views/home.handlebars 파일에 데이터를 렌더링한다. 
렌더링 시에 title과 message 값이 객체로 들어가게 된다.  
  
3. views 안에 layouts를 만들고 그 안에 main.handlebars 템플릿 파일을 생성한다. 핸들바 템플릿 엔진에서는 기본 형태가 되는 템플릿 파일을 선언하고 다른 
템플릿에서는 내용(body 태그 부분)만 변경하는 것이 기본 설정이다. main 템플릿을 사용하지 않으려면 결괏값의 json의 속성에 layout:false를 추가하면 
된다.  
  
board/views/layouts/main.handlebars  
  
{{{body}}}에 다른 핸들바 템플릿의 코드가 그대로 들어가게 된다.  
  
handlebars.engine에 layoutsDir 항목을 추가하면 기본 레이아웃 디렉터리를 변경할 수 있다.  
app.engine("handlebars", handlebars.engine({ layoutsDir: "views" ));  
  
혹은 기본 레이아웃을 사용하고 싶지 않으면 라우터의 결과 객체에 layout:false를 추가하면 된다.  
res.render("home", { title: "aa", message: "aa", layout: false });  
  
4. body에 삽입할 템플릿을 views 디렉터리 아래에 만든다.  
board/views/home.handlebars  
  
핸들바는 렌더링 시 {{ 변수명 }}으로 되어 있는 부분에 변수의 값을 넣어준다.  
  
![img.png](image/img5.png)  
  
5. node app.js를 실행 후 테스트를 진행한다.  
  
# **화면 기획하기**  
# **리스트 화면 기획**  
![img.png](image/img6.png)  
  
# **글쓰기 화면 기획**  
![img.png](image/img7.png)  
  
# **상세 화면 기획**  
![img.png](image/img8.png)  
  
# **UI 화면 만들기**  
# **리스트 UI 만들기**  
1. 리스트 페이지는 상단의 타이틀, 검색어, 글쓰기 버튼, 글 목록, 페이징 영역으로 나누어 구현한다.  
board/views/home.handlebars  
  
2. 서버를 기동시키기 전에 title을 변경해둔다.  
board/app.js  
  
3. 터미널에서 서버를 기동해 리스트 페이지를 확인한다.  
node app.js  
  
4. 서버가 문제없이 기동되었는지 브라우저로 확인한다.  
  
# **글쓴이 UI 만들기**  
다음으로 글쓰기 페이지를 만든다. app.js에 라우터 함수가 없으므로 라우터 함수도 추가한다.  
  
1. 먼저 템플릿부터 작성한다. board/views/ 디렉터리 아래에 템플릿을 작성한다.  
board/views/write.handlebars  
  
2. app.js에 핸들러 함수를 추가한다.  
board/app.js  
  
3. 서버의 코드가 변경되면 서버를 재기동해야 한다. 서버를 재기동한 뒤 테스트한다.  
  
# **상세페이지 UI 만들기**  
1. board/views 디렉터리 아래에 detail.handlebars 파일을 생성해 작성한다.  
board/views/detail.handlebars  
  
2. app.js에 핸들러 함수를 만들고 서버를 재기동해 화면을 확인한다.  
board/app.js  
  
# **API 만들기**  
몽고디비를 데이터 저장소로 사용한다. 모든 API는 ascyn await를 사용해 구현한다.  
  
# **몽고디비 연결을 위한 유틸리티 만들기**  
API 호출 시 데이터를 저장, 조회, 삭제하려면 데이터베이스와 연결해야 한다. 몽고디비 커넥션을 반환하는 유틸리티 함수를 만들어서 사용한다.  
  
1. configs/mongodb-connection.js 파일을 만들고 다음과 같이 작성한다. 아이디, 패스워드, 아틀라스 서버 주소는 본인의 것으로 적절하게 변경한다.  
board/configs/mongodb-connection.js  
  
주소 마지막에 board가 있는데 기본값으로 선택하는 데이터베이스를 의미한다. 데이터베이스를 명시적으로 생성하지 않으면 첫 데이터가 추가될 때 지정한 데이터베이스도 
자동으로 생성된다.  
  
커넥션 연결 함수는 함수를 호출하는 사람이 몽고디비의 uri값을 몰라도 사용할 수 있게 함수를 한 번 감쌌다. 함수의 결괏값으로 uri와 콜백 함수를 받는 
MongoDB.connection() 함수를 반환한다. 원래는 MongoClient.connect(uri, callback)을 실행해야 하지만 mongodb-conncetion(callback)으로 
감싸서 실행할 수 있다.  
  
MongoClient.connect() 함수는 두 번째 인수로 콜백 함수를 받는다. 콜백 함수의 두 번째 인수로 mongodb에 연결된 MongoClient 객체가 주어진다.  
  
2. mongodb-conncetion.js 코드를 app.js에 추가한다. 마지막 줄의 app.listen()의 경우 기존의 코드를 표시한 부분을 따라 수정하면 된다.  
board/app.js  
  
만들어둔 몽고디비 연결용 함수를 임포트한다. mongodbConnection(콜백 함수)와 같은 형태로 사용한다. 본문 코드에 콜백이 없으므로 콜백 실행 없이 MongoClient 
객체를 반환한다. 불러온 함수를 실행하면 결괏값으로 mongoClient 객체를 받을 수 있다. mongoClient에서 db()를 사용해 데이터베이스를 선택하고 
collection('post)를 사요해 컬렉션을 선택한다. db() 함수에 명시적으로 db('board')를 사용해도 된다. 데이터베이스 설정 파일에서 이미 기본 데이터베이스를 
board로 넣어두었으므로 여기서는 빈 값을 넣으면 된다. collection 변수는 클로벌 변수이다. mongodb 라이브러리 내부에서 커넥션 풀을 관리하고 있으므로 
글로벌 변수로 사용해도 문제가 없다.  
  
# **UI 페이지에서 사용할 핸들바 커스텀 헬퍼 만들기**  
핸들바의 장점이자 단점은 자유도가 높다는 점이다. 핸들바에서 each와 if 등 매우 기본적인 헬퍼 함수는 제공해주지만 그 이외의 것은 모두 만들어서 커스텀 
헬퍼 함수를 구현해 사용해야 한다. 게시판 프로젝트에서 필요한 커스텀 헬퍼 함수는 총 3개다. 각각 리스트 길이를 구하는 함수, 두 값이 같은지 비교하는 함수, 
ISO 데이터 포맷에서 날짜만 뽑아내는 함수가 필요하다. 커스텀 헬퍼를 사용하려면 설정도 조금 변경해야 한다.  
  
1. 헬퍼 함수를 만든다. board/configs 디렉터리에 생성한다.  
board/configs/handlebars-helpers.js  
  
헬퍼 함수 사용 시에는 {{헬퍼 함숩명 변수1 변수2}}와 같이 가장 처음에 함수명을 넣고 다음으로는 변수들을 빈 칸으로 구분해주면 된다. 헬퍼 함수 안에 다시 
헬퍼 함수를 사용해야 하는 경우 {{헬퍼 함수1 (헬퍼 함수2 변수1 변수2) 변수 11}} 처럼 {{}} 기호 안에 () 기호로 감싸준다.  
  
변수 . 과 @root는 각각 현재 겍체와 최상위 객체를 의미한다.  
  
2. 핸들바 커스텀 함수 설정을 진행한다. 기존 app.js에 app.engine으로 설정된 부분을 변경한다.  
board/app.js  
  
handlebars.create() 함수는 handlebars 객체를 만들 때 사용한다. 옵션에서 헬퍼 함수를 추가할 수 있다. helpers: require(...)로 커스텀 헬퍼 
함수를 추가한다. handlebars 객체에 있는 engine을 설정한다.  
  
# **nodemon 설정하기**  
서버 코드를 작성하면서 서버를 재시작하는 경우가 많다. 매번 서버를 껐다가 다시 켜는 것도 많은 코드를 작성할 때면 번거로울 수 있다. 그러므로 코드가 
저장되면 서버를 재시작시켜주는 도구가 있으면 좋다. 그런 용도로 Node.js에는 nodemon이라는 패키지가 있다.  
  
1. npm으로 nodemon 패키지를 설치한다.  
npm i nodemon@2.0.20  
  
설정은 해도 되고 안 해도 되지만 타이핑을 약간 더 줄여주는 효과가 있다.  
  
2. package.json의 script 부분에 코드를 추가한다.  
"start": "npx nodemon app.js"  
  
이렇게 하면 npm start 명령어로 서버를 기동시킬 수 있으며 nodemon에서 파일이 저장될 때마다 서버를 재기동시켜준다.  
  
# **글쓰기 API 만들기**  
POST 메서드 사용 시에는 데이터를 req.body로 넘기는데 해당 데이터를 사용하려면 익스프레스에 미들웨어를 설정해야 한다.  
  
1. 미들웨어 설정을 추가한다.  
board/app.js  
  
2. 글쓰기 API를 위해 app.js에 라우팅 설정을 하나 더 추가하고 글쓰기 로직을 추가한다.  
board/app.js  
  
저장 결과에는 도큐먼트의 식별자로 사용할 수 있는 insertedId값이 있다.  
  
3. 비즈니스 로직은 service 디렉터리 아래에 담는 게 좋다. services/post-service.js 파일을 생성하고 writePost를 작성한다.  
board/services/post-service.js  
  
4. 서버를 띄우고 테스트한다.  
  
# **리스트 API 만들기**  
## **템플릿 수정1: 리스트의 검색창 및 검색 버튼 수정**  
템플릿 파일의 검색창 부분을 수정해 검색어를 넣고 검색 버튼을 클릭 시 검색어 정보를 담아서 서버에 요청하도록 수정한다.  
  
1. home.handlebars 파일의 검색 버튼 부분을 다음과 같이 수정한다.  
board/views/home.handlebars  
  
value에는 서버에서 받은 search 데이터를 넣는다. 기본값은 빈 값이다. 검색 버튼은 클릭 시 이벤트를 추가했다. 자바스크립트를 최소한으로 하기 위해 
onclick 속성에 자바스크립트 함수를 한 줄로 넣었지만 별도의 자바스크립트 함수를 만들어서 추가해도 된다.  
  
## **리스트 API 백엔드 코드 작성**  
리스트 API를 만들면서 페이지네이터를 만들어주는 유틸리티 함수도 함께 만든다.  
  
1. app.js 파일을 만들 때 가장 먼저 만든 라우터 함수인 app.get("/"...) 부분을 다음과 같이 수정한다.  
board/app.js  
  
2. 이제 postService에 list() 함수를 추가한다.  
board/services/post-service.js  
  
몽고디비의 쿼리는 실제로 자바스크립트 문법과 매우 유사하며 SQL에서 사용하는 like와 같은 형식의 검색은 정규표현식을 사용한다. find()는 cursor를 
반환한다. cursor에는 여러 메서드가 있지만 여기서는 받아온 데이터를 배열로 변경하는 toArray() 메서드를 사용해 게시글 데이터를 리스트로 변경한다. 
옵션으로 limit, skip을 주었다. limit가 10이므로 최대 10개의 데이터만 쿼리를 한다. skip은 1ㅍ이지인 경우 1~10까지만 가져오기 위해 사용한다. 
toArray() 함수는 두 가지가 있다. 한 가지는 Promise를 사용하고 다른 것은 콜백을 사용한다.  
  
3. 페이지네이션 유틸을 작성한다.  
board/utils/paginator.js  
  
1부터 10까지 최대 10페이지가 나오도록 하려면 시작부터 끝 페이지까지의 숫자가 들어 있는 리스트를 만들어야 하는데 이를 편리하게 만들 수 있도록 하는 
함수가 lodash.range() 함수다. lodash.range(1, 11)을 실행하면 [1, ... 10]으로 구성된 리스트가 반환된다.  
  
lodash를 사용하려면 설치가 필요하다. 터미널에서 npm i lodash를 입력해서 설치한다.  
  
페이지네이터는 하나의 함수로 이루어져 있다. 변수로 게시물의 총 개수, 현재 페이지, 한 페이지당 표시하는 게시물 개수를 받는다.  
  
## **템플릿 수정2: 리스트 및 페이지네이션 추가**  
1. 리스트 템플릿에 리스트 및 페이지네이션을 추가한다.  
board/views/home.handlebars  
  

