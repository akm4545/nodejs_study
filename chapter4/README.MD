# **Node.js와 익스프레스로 웹 애플리케이션 서버 구현하기**  
# **OK를 반환하는 서버 만들기**  
1. 모든 요청에 "OK"를 반환해주는 서버를 다음과 같이 구현한다.  
code3-1-ok-server.js  
  
예제에서는 server에 값을 할당한 다음 listen()을 했지만 res.end("OK").listen() 같은 형태로 연결해서 사용할 수 있다.   
  
2. 서버를 실행 후 브라우저로 접속해서 OK가 나오면 성공이다.  
  
# **라우터 만들기**  
모든 요청에 OK로 응답하는 서버도 좋지만 일반적인 웹 서버는 URL 경로에 따라서 다른 응답을 준다. 이러한 기능을 라우팅이라고 한다. URL의 경로를 읽어서 
다른 응답을 주도록 코드를 수정한다.  
  
url 모듈을 사용하면 URL 경로를 간단하게 읽어올 수 있다.  
  
1. localhost:3000/user와 localhost:3000/feed라는 두 URL이 있다고 가정하고 두 요청에 대해 다른 응답을 주는 코드를 작성한다.  
code3-2-implement-router.js  
  
url 모듀을 사용해 요청으로 받은 url의 pathname을 얻을 수 있다. parse() 함수의 두 번째 인수로 있는 true는 쿼리 스트링도 함께 파싱할지 여부를 
설정하는 변수다.  
  
한글을 쓰면 출력된 값이 깨진다. 이는 charset이 설정되지 않아서이다. res.setHeader에 charset=utf-8을 추가해주면 한글이 깨지지 않는다.  
res.setHeader("Content-Type", "text/html; charset=utf-8");  
  
만든 url로 접속하면 응답을 받을 수 있다. 실제로 프로덕션 레벨에서 사용하는 라우터는 이보다 훨씬 복잡하다. 그렇지만 요청으로 들어온 정보를 
분석해서 라우팅하는 방법 자체는 같다.  
  
# **createServer() 리팩토링하기**  
현재는 요청에 대한 응답을 createServer() 안에서 직접 컨트롤한다. 이렇게 되면 createServer() 안의 콜백 함수에 모든 코드를 다 추가해야 하므로 
좋지 않다. 라우팅 이후의 처리를 별도의 함수를 만들어서 처리하도록 코드를 리팩토링한다.  
  
1. 라우터와 실행하는 함수 코드를 나눈다.  
code3-3-implement-router.js  
  
라우터 내부의 로직을 함수로 분리했다. 이제 메인 루틴을 깔끔히 유지하면서도 요청별 함수만 요구사항에 알맞게 변경하면 되는 코드가 되었다.  
  
# **동적으로 응답하기**  
앞에서 작성한 서버는 브라우저에서 localhost:3000/user에 접속하면 언제나 같은 결과를 보여 준다. user() 함수를 수정해서 매개변수에 따라 동적으로 
응답이 변경되도록 한다. url의 query 부분에 name과 age 정보를 추가한다.  
  
1. 먼저 user() 함수만 변경한다.  
code3-4-implement-router2.js  
  
url의 query 부분을 user라는 매개변수로 받는다. 응답을 줄 때 user.name, user.age를 사용한다. query를 사용해서 url을 요청하면 동적으로 
변하는 값을 볼 수 있다.  
  
