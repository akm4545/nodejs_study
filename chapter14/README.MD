# **웹소켓을 사용한 실시간 채팅 구현하기**  
# **웹소켓 소개**  
지금까지는 서버에 요청을 보내서 응답을 받는 애플리케이션을 만들었다. 사용자가 직접 화면을 갱신하지 않아도 자동으로 화면을 갱신하는 애플리케이션도 있다. 
주식이나 채팅 애플리케이션이 그 예이다. 이러한 일을 하려면 서버에 주기적으로 요청을 보내서 받아오거나 서버에서 데이터를 보내주어야 한다.  
  
![img.png](image/img.png)  
  
웹은 HTTP 프로토콜 위에서 동작하고 있기 때문에 요청을 보내야지만 서버가 응답을 주게 된다. 즉 양방향 통신을 지원하지 않는다. 그렇다고 주기적으로 
받아오는 것은 매우 비효율적이다. 몇 초에 한 번씩 서버가 알아서 응답을 주면 좋은데 단방향 통신이므로 클라이언트에서 주기적으로 의미없는 요청을 
보내야 하기 때문이다.  
  
![img.png](image/img2.png)  
  
이럴 때 웹소켓(WebSocket)을 사용한다. 웹소켓 이전에는 폴링 또는 롱폴링이라는 방법을 사용했다. 폴링은 주기적으로 요청을 보내는 방식이고 롱폴링은 
클라이언트와 서버 간의 커넥션을 유지한 상태로 응답을 주고받는 방식이다. 클라이언트가 서버로 요청을 보내면 서버는 클라이언트의 요청을 기다린다. 
그리고 요청한 데이터에 변화가 있을 때 응답을 보낸다. 폴링이나 롱폴링은 둘 다 클라이언트가 서버에 요청을 보내야 한다.  
  
![img.png](image/img3.png)  
  
웹소켓은 하나의 TCP 커넥션으로 서버와 클라이언트 간에 양방향 통신을 할 수 있게 만든 프로토콜이다. 2023년 기준 거의 대부분의 웹브라우저에서 안정적으로 
사용할 수 있다. 오래된 브라우저를 지원하려면 socket.io 같은 라이브러리를 사용해 폴링이나 롱폴링을 사용해 기능을 구현해야 한다. 웹소켓은 양방향 
통신을 지원하므로 브라우저 상에서 리프레시 없이 실시간성을 요구하는 애플리케이션을 구현할 수 있다.  
  
![img.png](image/img4.png)  
  
웹소켓의 특징은 크게 두 가지다. 첫 번째 특징은 양방향 통신이다. 이는 데이터의 송수신을 동시에 처리한다는 뜻이며 클라이언트와 서버가 원하는 때 
데이터를 주고받을 수 있다는 의미다. 통상적인 HTTP 통신은 클라이언트가 요청하는 때만 서버가 응답하는 단방향 통신이었다. 두 번째 특징으로는 실시간 
네트워킹을 구현하는 것이 용이하다는 것이다. 웹 환경에서 연속된 데이터를 빠르게 노출하고 싶은 때 (채팅, 주식) 적합하다. 또한 브로드캐스팅을 지원하므로 
여러 클라이언트와 빠르게 데이터를 교환할 수 있어 편리하다.  
  
# **웹소켓의 동작 방법**  
웹소켓 프로토콜은 크게 핸드 쉐이크와 데이터 전송으로 나눌 수 있다. 핸드 쉐이크는 서버와 클라이언트가 커넥션을 맺는 과정으로써 최초 한 번만 일어난다. 
이떄는 HTTP 1.1 프로토콜을 사용하고 헤더에 Upgrade: websocket과 Connection: Upgrade를 추가해서 웹소켓 프로토콜을 사용하도록 해준다.  
  
![img.png](image/img5.png)  
  
1단계에서는 HTTP 핸드쉐이크를 수행해 연결을 맺는다. 클라이언트가 다음과 같은 데이터를 서버로 보낸다.  
  
![img.png](image/img6.png)  
  
핸드쉐이킹은 GET으로 보내야 하며 HTTP 1.1 이상이 필수다. Upgrade 필드는 HTTP 프로토콜에서 웹소켓 프로토콜로 변경에 필요한 값이다. 프로토콜을 
업그레이드하려면 반드시 명시해야 한다. Connection: Upgrade 는 Upgrade 필드가 있으면 반드시 같이 명시해야 한다. 없으면 연결이 되지 않는다. 
Sec-WebSocket-Protocol은 클라이언트가 요청하는 하위 프로토콜이다. 순서에 따라서 우선순위를 부여하며 서버에서 여러 프로토콜이나 프로토콜 버전을 나눠서 
서비스할 때 필요한 정보다.  
  
그러면 서버는 핸드쉐이크의 응답으로 다음과 같은 데이터를 보내준다.  
  
![img.png](image/img7.png)  
  
101 Switching Protocols로 응답이 오면 웹소켓 프로토콜로 전환되어 연결이 잘된다는 것을 의미한다. 이제부터는 양방향 송수신을 할 수 있다. 
Sec-WebSocket-Accept는 클라이언트로부터 받은 키를 사용해 계산한 값이다. 해당 값은 클라이언트와 서버 간 인증에 사용된다. 핸드쉐이크가 완료되면 
프로토콜이 HTTP에서 ws로, HTTPS라면 wss로 변경되어 데이터를 전송할 수 있는 2단계로 접어든다. 데이터는 메시지(message)라 부르며 메시지는 프레임(frame)
의 모음이다. 프레임은 바이트의 배열이며 다음과 같은 형태를 가진다.  
  
![img.png](image/img8.png)  
  
프레임은 헤더와 페이로드(Payload)로 이루어져 있다. 헤더는 FIN, RSV1~3, 오프코드(opcode), 마스크(MASK), 페이로드 길이, 마스킹 키가 있다.  
  
![img.png](image/img9.png)  
  
마지막 3단계에서는 접속을 끊는다. 접속은 클라이언트와 서버 양쪽에서 모두 끊을 수 있으며 opcode에 1000을 담아서 보내면 된다.  
  
웹소켓은 데이터를 전송하는 것만 지원할 뿐 전송되는 데이터를 가지고 무엇을 할지는 개발자의 몫이다. socket.io를 사용하면 추가로 이런 부분들을 
지원해주므로 웹소켓보다는 코드 작성의 부담이 적다.  
  
# **메아리 애플리케이션 만들기: 웹소켓**  
클라이언트에서 메시지를 보내면 서버에서 같은 메시지를 반환하는 프로그램이다.  
  
# **ws 패키지 설치하기**  
1. ws는 Node.js에서 웹소켓 서버를 구동하는 라이브러리다. 먼저 프로젝트 디렉터리를 생성하고 패키지를 설치한다. echo-websocket 디렉터리를 프로젝트 
디렉터리로 생성한다.  
npm install ws  
  
echo-websocket 디렉터리 아래에 package.json과 package-lock.json 파일, node_modules 디렉터리가 생성된다.  
  
# **서버 측 구축하기: server.js 파일 작성 및 서버 구동**  
ws 패키지를 설치했으니 이제 웹소켓 서버를 Node.js를 사용해 구동할 수 있다. 웹소켓은 서버와 클라이언트가 양방향으로 통신하는 프로토콜이므로 서버와 
클라이언트를 모두 작성해야 한다. 서버는 Node.js를, 클라이언트는 웹브라우저를 사용한다.  
  
1. 먼저 서버를 구동하기 위해 server.js 파일을 생성하고 다음과 같이 작성한다.  
echo-websocket/server.js  
  
ws의 Server() 함수를 사용해 서버 인스턴스를 생성하고 server 변수에 저장한다. server는 WebSocketServer 클래스의 인스턴스다. 웹소켓 서버(server 변수)의 
on() 함수는 이벤트를 받는 함수다. 첫 번째 인수로 이벤트 유형을 받는다. connection은 클라이언트가 접속 시 발생하는 이벤트다. 두 번째 인수로 
이벤트 발생 시 실행할 콜백 함수를 인수로 설정한다. 콜백 함수의 인수로 ws를 받는데 WebSocket 클래스의 인스턴스다.  
  
![img.png](image/img10.png)  
  
ws.on() 함수는 클라이언트에서 이벤트가 발생할 때 실행하는 함수다. WebSocketServer의 on() 함수처럼 첫 번째는 이벤트 타입, 두 번째는 콜백 함수를 
인수로 사용한다. ws.on('message')는 클라이언트로부터 메시지가 서버로 발송되었을 때 실행한다.  
  
![img.png](image/img11.png)  
  
ws.on('close', 콜백 함수)는 클라이언트가 접속을 종료했을 때 실행한다.  
  
# **클라이언트 측 구현하기: client.html 파일 작성**  
1. 클라이언트로 사용할 index.html 파일에 웹소켓 연결을 하고 메시지를 주고받을 수 있도록 작성한다.  
echo-websocket/client.html  
  
웹소켓 연결은 new WebSocket(서버 주소)를 하면 맺어진다. 웹브라우저에는 웹소켓 기능이 이미 있기 때문에 별도로 라이브러리를 추가하지 않아도 된다. 
반환값으로 WebSocket의 인스턴스가 돌아오는데 해당 값을 ws 변수에 저장한다.  
  
send()는 메시지를 서버로 발송하는 함수다. 서버에서는 웹소켓의 message 이벤트가 발생한다.  
  
close()는 웹소켓 연결 종료 시 사용하는 함수다.  
  
onopen()은 서버와 연결되면 발생하는 이벤트인 open의 이벤트 핸들러다. 서버와 연동되면 실행한다.  
  
onmessage()는 서버에서 메시지를 수신하면 발생하는 이벤트의 핸들러다.  
  
# **테스트하기**  
1. 우선 서버를 띄운다.  
node server.js  
  
터미널에 아무 값도 안 올라오지만 에러가 나면서 종료되는 게 아니라면 성공이다.  
  
2. 다음으로 브라우저에서 client.html을 실행해서 서버에 접속한다.  
  
3. 개발자 도구의 네트워크 탭으로 들어가면 client.html이 있고 localhost가 있다. localhost를 선택하면 데이터가 출력된다. 아래 화살표는 서버에서부터 
메시지를 받았다는 의미다. 위쪽 화살표는 서버로 메시지를 보낸다는 의미다.  
  
4. 텍스트 영역에 입력 후 전송 버튼을 클릭해 서버로 메시지를 보낸다.  
  
5. 종료 버튼을 눌러서 연결을 끊는다.  
  
# **향후 과제 확인**  
브라우저를 두 개 띄워서 테스트를 해보면 메세지를 공유하는게 아닌 따로따로 동작한다. 이는 웹소켓의 경우 메시지를 브로드캐스팅(접속한 클라이언트에 각각 
보내주는 것) 기능을 따로 구현해야 하기 떄문이다. 웹소켓은 데이터를 주고받을 수 있게 하는 것뿐이라서 웹소켓을 사용하는 경우 데이터 전송 이외의 부분은 
모두 개발자가 개발해야 한다.  
  
그래서 웹소켓으로 된 애플리케이션을 만들 때 도움을 주는 sockjs, socket.io 같은 라이브러리 구현체들이 있다. 이 중 대표적인 것이 socket.io이고 
채팅방 기능이나 연결이 끊어졌을 때 재접속, 브로드캐스팅 기능을 제공해준다.  
  
# **간단한 채팅 애플리케이션 만들기: socket.io**  
이전에는 프레임워크의 도움 없이 웹소켓을 사용했다. 이번에는 NestJS로 채팅 애플리케이션을 구현한다. 채팅을 만들려면 채팅방도 만들어야 하고 접속한 
유저 모두에게 메시지를 발송하는 브로드캐스팅 기능도 필요하고 접속이 의도치 않게 끊어졌을 때 재접속하는 방법도 필요하다. 웹소켓은 프로토콜이기 떄문에 
이렇게 특화된 기능은 제공하지 않고 메시지 전송만을 제공해주고 있어서 개발자가 모든 것을 다 만들어야 한다.  
  
socket.io는 웹소켓을 기반으로 서버와 클라이언트의 양방향 통신을 지원하는 라이브러리다. 기본적으로 웹소켓을 지원한다. 웹소켓을 지원하지 않는 브라우저에서는 
롱폴링 방식을 사용한 통신을 지원한다. 또한 재접속, 브로드캐스팅, 멀티플렉싱(채팅방) 기능도 제공한다.  
  
NestJS에서는 웹소켓과 socket.io 기반의 실시간 애플리케이션 제작을 모두 지원한다.  
  
# **socket.io 프로젝트 생성하기**  
nest new nest-chat --skip-git  
  
test 디렉터리와 src/app.controller.spec.ts는 사용하지 않으므로 삭제한다.  
  
