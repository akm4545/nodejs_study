# **웹소켓을 사용한 실시간 채팅 구현하기**  
# **웹소켓 소개**  
지금까지는 서버에 요청을 보내서 응답을 받는 애플리케이션을 만들었다. 사용자가 직접 화면을 갱신하지 않아도 자동으로 화면을 갱신하는 애플리케이션도 있다. 
주식이나 채팅 애플리케이션이 그 예이다. 이러한 일을 하려면 서버에 주기적으로 요청을 보내서 받아오거나 서버에서 데이터를 보내주어야 한다.  
  
![img.png](image/img.png)  
  
웹은 HTTP 프로토콜 위에서 동작하고 있기 때문에 요청을 보내야지만 서버가 응답을 주게 된다. 즉 양방향 통신을 지원하지 않는다. 그렇다고 주기적으로 
받아오는 것은 매우 비효율적이다. 몇 초에 한 번씩 서버가 알아서 응답을 주면 좋은데 단방향 통신이므로 클라이언트에서 주기적으로 의미없는 요청을 
보내야 하기 때문이다.  
  
![img.png](image/img2.png)  
  
이럴 때 웹소켓(WebSocket)을 사용한다. 웹소켓 이전에는 폴링 또는 롱폴링이라는 방법을 사용했다. 폴링은 주기적으로 요청을 보내는 방식이고 롱폴링은 
클라이언트와 서버 간의 커넥션을 유지한 상태로 응답을 주고받는 방식이다. 클라이언트가 서버로 요청을 보내면 서버는 클라이언트의 요청을 기다린다. 
그리고 요청한 데이터에 변화가 있을 때 응답을 보낸다. 폴링이나 롱폴링은 둘 다 클라이언트가 서버에 요청을 보내야 한다.  
  
![img.png](image/img3.png)  
  
웹소켓은 하나의 TCP 커넥션으로 서버와 클라이언트 간에 양방향 통신을 할 수 있게 만든 프로토콜이다. 2023년 기준 거의 대부분의 웹브라우저에서 안정적으로 
사용할 수 있다. 오래된 브라우저를 지원하려면 socket.io 같은 라이브러리를 사용해 폴링이나 롱폴링을 사용해 기능을 구현해야 한다. 웹소켓은 양방향 
통신을 지원하므로 브라우저 상에서 리프레시 없이 실시간성을 요구하는 애플리케이션을 구현할 수 있다.  
  
![img.png](image/img4.png)  
  
웹소켓의 특징은 크게 두 가지다. 첫 번째 특징은 양방향 통신이다. 이는 데이터의 송수신을 동시에 처리한다는 뜻이며 클라이언트와 서버가 원하는 때 
데이터를 주고받을 수 있다는 의미다. 통상적인 HTTP 통신은 클라이언트가 요청하는 때만 서버가 응답하는 단방향 통신이었다. 두 번째 특징으로는 실시간 
네트워킹을 구현하는 것이 용이하다는 것이다. 웹 환경에서 연속된 데이터를 빠르게 노출하고 싶은 때 (채팅, 주식) 적합하다. 또한 브로드캐스팅을 지원하므로 
여러 클라이언트와 빠르게 데이터를 교환할 수 있어 편리하다.  
  
# **웹소켓의 동작 방법**  
웹소켓 프로토콜은 크게 핸드 쉐이크와 데이터 전송으로 나눌 수 있다. 핸드 쉐이크는 서버와 클라이언트가 커넥션을 맺는 과정으로써 최초 한 번만 일어난다. 
이떄는 HTTP 1.1 프로토콜을 사용하고 헤더에 Upgrade: websocket과 Connection: Upgrade를 추가해서 웹소켓 프로토콜을 사용하도록 해준다.  
  
![img.png](image/img5.png)  
  
1단계에서는 HTTP 핸드쉐이크를 수행해 연결을 맺는다. 클라이언트가 다음과 같은 데이터를 서버로 보낸다.  
  
![img.png](image/img6.png)  
  
핸드쉐이킹은 GET으로 보내야 하며 HTTP 1.1 이상이 필수다. Upgrade 필드는 HTTP 프로토콜에서 웹소켓 프로토콜로 변경에 필요한 값이다. 프로토콜을 
업그레이드하려면 반드시 명시해야 한다. Connection: Upgrade 는 Upgrade 필드가 있으면 반드시 같이 명시해야 한다. 없으면 연결이 되지 않는다. 
Sec-WebSocket-Protocol은 클라이언트가 요청하는 하위 프로토콜이다. 순서에 따라서 우선순위를 부여하며 서버에서 여러 프로토콜이나 프로토콜 버전을 나눠서 
서비스할 때 필요한 정보다.  
  
그러면 서버는 핸드쉐이크의 응답으로 다음과 같은 데이터를 보내준다.  
  
![img.png](image/img7.png)  
  
101 Switching Protocols로 응답이 오면 웹소켓 프로토콜로 전환되어 연결이 잘된다는 것을 의미한다. 이제부터는 양방향 송수신을 할 수 있다. 
Sec-WebSocket-Accept는 클라이언트로부터 받은 키를 사용해 계산한 값이다. 해당 값은 클라이언트와 서버 간 인증에 사용된다. 핸드쉐이크가 완료되면 
프로토콜이 HTTP에서 ws로, HTTPS라면 wss로 변경되어 데이터를 전송할 수 있는 2단계로 접어든다. 데이터는 메시지(message)라 부르며 메시지는 프레임(frame)
의 모음이다. 프레임은 바이트의 배열이며 다음과 같은 형태를 가진다.  
  
![img.png](image/img8.png)  
  
프레임은 헤더와 페이로드(Payload)로 이루어져 있다. 헤더는 FIN, RSV1~3, 오프코드(opcode), 마스크(MASK), 페이로드 길이, 마스킹 키가 있다.  
  
![img.png](image/img9.png)  
  
마지막 3단계에서는 접속을 끊는다. 접속은 클라이언트와 서버 양쪽에서 모두 끊을 수 있으며 opcode에 1000을 담아서 보내면 된다.  
  
웹소켓은 데이터를 전송하는 것만 지원할 뿐 전송되는 데이터를 가지고 무엇을 할지는 개발자의 몫이다. socket.io를 사용하면 추가로 이런 부분들을 
지원해주므로 웹소켓보다는 코드 작성의 부담이 적다.  
  
# **메아리 애플리케이션 만들기: 웹소켓**  
클라이언트에서 메시지를 보내면 서버에서 같은 메시지를 반환하는 프로그램이다.  
  
# **ws 패키지 설치하기**  
1. ws는 Node.js에서 웹소켓 서버를 구동하는 라이브러리다. 먼저 프로젝트 디렉터리를 생성하고 패키지를 설치한다. echo-websocket 디렉터리를 프로젝트 
디렉터리로 생성한다.  
npm install ws  
  
echo-websocket 디렉터리 아래에 package.json과 package-lock.json 파일, node_modules 디렉터리가 생성된다.  
  
# **서버 측 구축하기: server.js 파일 작성 및 서버 구동**  
ws 패키지를 설치했으니 이제 웹소켓 서버를 Node.js를 사용해 구동할 수 있다. 웹소켓은 서버와 클라이언트가 양방향으로 통신하는 프로토콜이므로 서버와 
클라이언트를 모두 작성해야 한다. 서버는 Node.js를, 클라이언트는 웹브라우저를 사용한다.  
  
1. 먼저 서버를 구동하기 위해 server.js 파일을 생성하고 다음과 같이 작성한다.  
echo-websocket/server.js  
  
ws의 Server() 함수를 사용해 서버 인스턴스를 생성하고 server 변수에 저장한다. server는 WebSocketServer 클래스의 인스턴스다. 웹소켓 서버(server 변수)의 
on() 함수는 이벤트를 받는 함수다. 첫 번째 인수로 이벤트 유형을 받는다. connection은 클라이언트가 접속 시 발생하는 이벤트다. 두 번째 인수로 
이벤트 발생 시 실행할 콜백 함수를 인수로 설정한다. 콜백 함수의 인수로 ws를 받는데 WebSocket 클래스의 인스턴스다.  
  
![img.png](image/img10.png)  
  
ws.on() 함수는 클라이언트에서 이벤트가 발생할 때 실행하는 함수다. WebSocketServer의 on() 함수처럼 첫 번째는 이벤트 타입, 두 번째는 콜백 함수를 
인수로 사용한다. ws.on('message')는 클라이언트로부터 메시지가 서버로 발송되었을 때 실행한다.  
  
![img.png](image/img11.png)  
  
ws.on('close', 콜백 함수)는 클라이언트가 접속을 종료했을 때 실행한다.  
  
# **클라이언트 측 구현하기: client.html 파일 작성**  
1. 클라이언트로 사용할 index.html 파일에 웹소켓 연결을 하고 메시지를 주고받을 수 있도록 작성한다.  
echo-websocket/client.html  
  
웹소켓 연결은 new WebSocket(서버 주소)를 하면 맺어진다. 웹브라우저에는 웹소켓 기능이 이미 있기 때문에 별도로 라이브러리를 추가하지 않아도 된다. 
반환값으로 WebSocket의 인스턴스가 돌아오는데 해당 값을 ws 변수에 저장한다.  
  
send()는 메시지를 서버로 발송하는 함수다. 서버에서는 웹소켓의 message 이벤트가 발생한다.  
  
close()는 웹소켓 연결 종료 시 사용하는 함수다.  
  
onopen()은 서버와 연결되면 발생하는 이벤트인 open의 이벤트 핸들러다. 서버와 연동되면 실행한다.  
  
onmessage()는 서버에서 메시지를 수신하면 발생하는 이벤트의 핸들러다.  
  
# **테스트하기**  
1. 우선 서버를 띄운다.  
node server.js  
  
터미널에 아무 값도 안 올라오지만 에러가 나면서 종료되는 게 아니라면 성공이다.  
  
2. 다음으로 브라우저에서 client.html을 실행해서 서버에 접속한다.  
  
3. 개발자 도구의 네트워크 탭으로 들어가면 client.html이 있고 localhost가 있다. localhost를 선택하면 데이터가 출력된다. 아래 화살표는 서버에서부터 
메시지를 받았다는 의미다. 위쪽 화살표는 서버로 메시지를 보낸다는 의미다.  
  
4. 텍스트 영역에 입력 후 전송 버튼을 클릭해 서버로 메시지를 보낸다.  
  
5. 종료 버튼을 눌러서 연결을 끊는다.  
  
# **향후 과제 확인**  
브라우저를 두 개 띄워서 테스트를 해보면 메세지를 공유하는게 아닌 따로따로 동작한다. 이는 웹소켓의 경우 메시지를 브로드캐스팅(접속한 클라이언트에 각각 
보내주는 것) 기능을 따로 구현해야 하기 떄문이다. 웹소켓은 데이터를 주고받을 수 있게 하는 것뿐이라서 웹소켓을 사용하는 경우 데이터 전송 이외의 부분은 
모두 개발자가 개발해야 한다.  
  
그래서 웹소켓으로 된 애플리케이션을 만들 때 도움을 주는 sockjs, socket.io 같은 라이브러리 구현체들이 있다. 이 중 대표적인 것이 socket.io이고 
채팅방 기능이나 연결이 끊어졌을 때 재접속, 브로드캐스팅 기능을 제공해준다.  
  
# **간단한 채팅 애플리케이션 만들기: socket.io**  
이전에는 프레임워크의 도움 없이 웹소켓을 사용했다. 이번에는 NestJS로 채팅 애플리케이션을 구현한다. 채팅을 만들려면 채팅방도 만들어야 하고 접속한 
유저 모두에게 메시지를 발송하는 브로드캐스팅 기능도 필요하고 접속이 의도치 않게 끊어졌을 때 재접속하는 방법도 필요하다. 웹소켓은 프로토콜이기 떄문에 
이렇게 특화된 기능은 제공하지 않고 메시지 전송만을 제공해주고 있어서 개발자가 모든 것을 다 만들어야 한다.  
  
socket.io는 웹소켓을 기반으로 서버와 클라이언트의 양방향 통신을 지원하는 라이브러리다. 기본적으로 웹소켓을 지원한다. 웹소켓을 지원하지 않는 브라우저에서는 
롱폴링 방식을 사용한 통신을 지원한다. 또한 재접속, 브로드캐스팅, 멀티플렉싱(채팅방) 기능도 제공한다.  
  
NestJS에서는 웹소켓과 socket.io 기반의 실시간 애플리케이션 제작을 모두 지원한다.  
  
# **socket.io 프로젝트 생성하기**  
nest new nest-chat --skip-git  
  
test 디렉터리와 src/app.controller.spec.ts는 사용하지 않으므로 삭제한다.  
  
# **패키지 설치하기**  
양방향 통신 애플리케이션을 작성하려면 @nestjs/websockets과 @nestjs/platform-socket.io 패키지가 필요하다. 첫 번째 @nestjs/websockets 패키지는 
웹소켓 프로토콜 기반의 프로그램 작성 시에는 꼭 필요하다. @nestjs/platform-socket.io는 @nestjs/platform-ws로 변경할 수도 있다. @nestjs/platform-ws를 
사용하면 socket.io가 아닌 웹소켓을 사용한다. 우리는 socket.io를 사용하므로 @nestjs/platform-socket.io를 설치한다. 또한 개발 시 타입 정보를 편하게 
가져오기 위해 @types/socket.io도 개발용 패키지로 설치한다.  
  
npm i @nestjs/websockets @nestjs/platform-socket.io  
npm i -D @types/socket.io  
  
# **html 파일을 불러오도록 main.ts 설정하기**  
프레임워크를 사용하지 않았을 때는 .html 파일을 직접 열어서 테스트했다. NestJS에서는 정적 파일을 불러오는 기능을 제공한다. 이전에는 server-static 패키지를 
설치했지만 이번에는 익스프레스를 사용해서 정적 파일을 서비스할 수 있게 설정을 추가한다. 설정이 간단할 때는 익스프레스, 정밀한 설정을 원할 때는 server-static을 
사용하면 된다.  
nest-chat/src/main.ts  
  
NestFactory.create() 메서드에 NestExpressApplication으로 반환값의 타입을 지정했다. NestExpressApplication에는 useStaticAssets() 
메서드가 있다. 해당 메서드는 정적 파일의 경로를 지정하는 데 사용한다.  
  
useStaticAssets()에 정적 파일의 경로를 지정한다.  
  
다음으로 static 디렉터리 아래에 index.html 파일을 생성한다. index.html로 하면 URL 경로와 파일명을 모두 적지 않고 경로만 적어도 index.html을 
불러오기 떄문에 테스트가 편하다. 잘 불러오는지만 테스트하는 용도이므로 간단히 코드를 작성한다.  
nest-chat/static/index.html  
  
# **서버 측 작업을 위한 게이트웨이 만들기**  
NestJS에서는 웹소켓을 사용한 통신을 받아주는 클래스를 게이트웨이라고 부른다. 컨트롤러 클래스와 같은 개념이라고 생각하면 된다. 게이트웨이를 사용하면 
의존성 주입, 데코레이터, 필터, 가드 등의 NestJS 기능을 사용할 수 있다. 단순하게 말하자면 프로토콜이 HTTP라면 컨트롤러로부터 요청을 받고 프로토콜이 
ws라면 게이트웨이로부터 요청을 받는 차이다. 진입점이 다르고 사용하는 데코레이터가 약간 달라진다.  
  
![img.png](image/img12.png)  
  
게이트웨이를 만드는 방법은 쉽다. @WebSocketGateway() 데코레이터를 클래스에 붙이면 해당 클래스는 게이트웨이 역할을 한다. nest-cli 명령어로 만들 
수 있지만 불필요한 디렉터리가 생성된다. 그러므로 수동으로 작성한다.  
cli -> nest g gateway chat -> src/chat/chat.gateway.ts  
  
게이트웨이 파일을 다음과 같이 작성한다.  
nest-chat/src/app.gateway.ts  
  
@WebSocketGateway() 데코레이터는 게이트웨이 설정을 위한 데코레이터다. 내부적으로는 socket.io 서버를 생성하는 것과 같고 생성 시의 옵션도 동일하게 
줄 수 있다. socket.io 서버 옵션 중 자주 사용하는 옵션은 네임스페이스(namespace)가 있다. 다른 옵션들은 저수준의 옵션이 많으니 크게 사용할 일이 
많지는 않다.  
  
![img.png](image/img13.png)  
  
@WebSocketServer()는 웹소켓 서버 인스턴스에 접근하는 데코레이터다. 직접 웹소켓 서버의 인스턴스를 생성하는 것이 아니기에 웹소켓 인스턴스 접근은 
@WebSocketServer() 데코레이터를 사용해야 한다.  
  
@SubscribeMessage('message')는 'message'라는 이벤트를 구독하는 리스너다. 클라이언트에서 message라는 이벤트로 데이터가 전송되는 경우 data 인수에 
데이터가 담겨 있다. socket: Socket은 하나의 웹소켓 연결에 대한 인스턴스다. @SubcribeMessage() 데코레이터가 붙어 있는 메서드는 socket과 data 
두 가지 인수를 사용할 수 있는데 필요 없는 떄는 생략할 수 있다. 다만 생략하면 매개변수의 순서를 변경할 때 별도의 데코레이터를 붙여주어야 한다. 
data는 @MessageBody() 데코레이터가 필요하며 socket에는 @ConnectedSocket() 데코레이터가 필요하다. socket이 필요 없는 함수라면 handleMessage(@MessageBody() data)와 
같은 형태로 사용할 수 있다.  
  
웹소켓 서버 인스턴스의 emit() 메서드를 사용해 클라이언트 전체에 메시지를 보낸다. 첫 번쨰 인수인 message는 이벤트명, 두 번째 인수는 보내주는 
데이터다. socket.io에서는 모든 클라이언트 인스턴스에 임의의 id 값을 준다. id에는 무작위 문자열이 저장되어 있다.  
  
